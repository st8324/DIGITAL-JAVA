1. 변수
 - 일반변수 : 값을 저장하는 변수
   - 정수형 : int, byte, short, long
   - 실수형 : float, double
   - 문자형 : char
 - 참조변수 : 주소를 저장하는 변수
 - 자료형변환 : 변수나 상수 값의 자료형을 일시적으로 다른 자료형으로 변환
   - 자동 : 정수->실수, 작은 바이트->큰바이트
   - 명시적 : 자동 자료형변환이 되지 않아서 에러가 발생하거나 자료형변환이 필요한 경우
 float vs double
 - 4바이트 vs 8바이트
 - 소수점 7자리 vs 소수점 15자리
 - 접미사 f필요 vs 접미사 필요 없음

2. 연산자
 - 대입연산자(=)
   - 오른쪽에 있는 값을 왼쪽에 저장
   - 왼쪽에는 무조건 변수/객체가 와야한다.
   - 왼쪽과 오른쪽의 자료형이 같아야 한다.
   - 다르다면 오른족에 있는 값의 자료형이 왼쪽에 있는 값의 자료형으로 형변환이 가능해야한다.
 - 산술연산자(+,-,*,/,%)
   - / : 0으로 나눌 수 없다, 정수 / 정수 => 정수
 - 논리연산자(&&, ||, !)
   - 결과가 참 또는 거짓 => 조건식
   - && : ~하고, 둘다 참이면 참, 나머진 다 거짓
   - || : ~하거나, 둘다 거짓이면 거짓, 나머진 다 참
   - ! : 반대, 거짓이면 참, 참이면 거짓
 - 비교연산자(<, >, <=, >=, ==, !=)
   - 조건식
   - ==와 =을 구별
 - 조건선택연산자( 조건식?값1:값2; )
   - 조건식이 참이면 값1을, 거짓이면 값2를 선택
 - 증감연산자(++, --)
   - 최종적으로 1증가, 1감소

3. 조건식 : ~하면 ...한다. ~ : 조건식, ... : 실행문
 - if문
//조건식1이 참이면 실행문1을 실행해라
if(조건식1){
	실행문1;
}
//조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행해라
else if(조건식2){
	실행문2;
}
//조건식1과 조건식2가 거짓이면 실행문3을 실행해라
else{
	실행문3;
}

성적을 정수로 입력받아 입력받은 성적에 맞는 학점을 출력하는 코드를 작성하세요.
A+ : 100~95
A   : 94~90 
B+ : 89~85
B   : 84~80 
C+ : 79~75
C   : 74~70
D+ : 69~65
D   : 64~60
F   : 0~59

 - switch문
switch(변수){
//변수가 값1과 같으면 실행문1을 실행
case 값1:
	실행문1;
	break;
//변수가 값1과 다르고, 값2와 같으면 실행문2를 실행
case 값2:
	실행문2;
	break;
//변수가 값1과 값2와 같지 않으면 실행문3을 실행
default:
	실행문3;
}
 - 변수가 사용하는 값이 제한적인 때
 - 변수가 아닌, 식이 들어가서 식의 값이 제한적일 때 (%)

4. 반복문 : 규칙성, 반복횟수
 - for문
for(1.초기화 ; 2.조건식 ; 4.증감연산식){
	3. 실행문;
}
1. 초기화 : 조건식이나 실행문에서 사용하는 변수를 초기화, 생략 가능
2. 조건식 : 반복문이 실행되기 위한 조건으로, 참이면 반복문 실행, 거짓이면 반복문 종료,
	 생략 가능
4. 증감연산식 : 조건식에서 사용하는 변수를 증가 또는 감소=>반복횟수를 조정하기 위해,
	 생략 가능

 - for문을 이용하여 구구단 9단을 출력하는 코드를 작성하세요.
 - for문을 이용하여 문자를 입력받고 입력받은 문자가 y또는 Y이면 반복문을 종료하는
   코드를 작성하세요.
 - while문
while(조건식){
	실행문;
}
 - while문 이용하여 구구단 9단을 출력하는 코드를 작성하세요.
 - while문을 이용하여 문자를 입력받고 입력받은 문자가 y 또는 Y이면 반복문을 종료하는 코드를 작성하세요.
 - do while문
do{
	실행문;
}while(조건식);
   - 최소 1번은 실행되는 반복문
 - break 
   - 반복문을 빠져 나가는 역할/switch문을 빠져 나가는 역할
   - if문과 같이 쓰임
 - continue
   - continue를 만나면 for문의 경우 증감연산식으로, while문 경우 조건식으로
 - 1부터 10까지의 짝수의 합을 반복문과 continue를 이용하여 작성하세요.

 - 이중 반복문

5. 배열
 - 동일한 자료형을 가진 데이터를 모아 놓은 것
 - 배열 선언
자료형 배열명 [];
자료형 [] 배열명;
 - 배열 생성
자료형 배열명 [] = new 자료형[갯수];
 - 0번지부터 시작
 - 마지막번지는 크기-1번지
 배열명[번지] = 값; //배열에 값을 설정
 변수 = 배열명[번지];//배열에 있는 값을 가져옴

6. 클래스 : 데이터를 편하게 관리 하기 위해
 - 멤버변수
 - 멤버메서드
 - 생성자

 - 메서드 : 기능 => 입력정보(매개변수) => 결과(리턴타입)
  - 기능정리
  - 매개변수 : 메서드를 실행하기 위해 필요한 최소한의 정보
  - 리턴타입 : 기능이 실행된 후 알려줘야하는 정보
  - 메소드명

 - 메서드를 만드는 이유
  - 재사용성을 높여서 코드의 길이를 줄임
  - 유지보수를 쉽게 하기 위해

 - 두 실수와 산술연산자가 주어지면 산술 연산결과를 출력하는 코드를 작성하기 위한 메서드를 만드세요.
 - 1부터 10까지 합을 구하는 코드를 메서드를 만들어서 작성하세요.

 - 메서드 오버로딩 : 이름이 같은 메서드가 여러개인 경우
   - 매개변수가 다를 때
     - 매개변수의 타입이 다른 경우
     - 매개변수의 갯수가 다른 경우

 - 클래스 멤버(static)
   - 모든 객체들이 공유하는 멤버
   - 객체를 생성하지 않고 호출
   - 클래스를 사용할 때
 - 객체 멤버
   - 각 객체마다 멤버를 가지고 있다.
   - 객체를 생성한 후에 호출
   - 객체를 생성할 때(new 연산자를 통해)

클래스 멤버 변수를 클래스 멤버 메서드에서 호출할 수 있다. O
클래스 멤버 변수를 객체 맴버 메서드에서 호출할 수 있다.O
객체 멤버 변수를 객체 멤버 메서드에서 호출할 수 있다. O
객체 멤버 변수를 클래스 멤버 메서드에서 호출할 수 있다.X

 - 생성자 : 객체를 생성하고 초기화 할때 호출되는 메서드
   - 접근제한자 : public
   - 생성자 이름은 클래스 이름을 따른다
   - 리턴타입이 없다

Car car = new Car();
 - 객체를 만드는 코드 : new
 - 객체를 초기화 코드 : Car()

 - 접근제한자 : public > protected > default   > private
   - public 	: 나 + 같은 패키지 + 자식 클래스 + 다른 패키지
   - protected 	: 나 + 같은 패키지 + 자식 클래스
   - default 	: 나 + 같은 패키지
   - private	: 나

 - final 
   - 변수 : 상수
   - 메서드 : 오버라이딩을 할 수 없다
   - 클래스 : 부모가 될 수 없다

 - 2차원 좌표 평면의 한 점을 나타내는 Point 클래스를 만들고, 테스트해보세요.
   - 멤버변수 설정
   - getter/setter
   - 생성자
   - 필요한 기능 => 메서드

 - 에러 : 코드의 수정으로 해결할 수 없는 상황
 - 예외 : 코드의 수정으로 해결할 수 있는 상황
 - 예외처리 : Exception
 - 예외처리 방법
  1. 본인이 처리하는 방법
     try{}catch()
  2. 메서드를 호출한 곳에서 처리하는 방법
     throw
     메서드에 throws를 통해 예외를 꼭 적어줘야하는 경우 
      - RuntimeException이 아닌 경우
 - 대표적인 예외 상황
  1. 0으로 나누었을 때
  2. 배열의 번지가 잘못된 번지인 경우 : 음수나 배열의 크기보다 같거나 큰 경우
  3. 객체가 생성되지 않아서 NULL값인데 객체의 멤버 메서드에 접근하려할 때
  4. 클래스의 형변환이 되지 않은데 형변환하려할때

 - 예외 발생 시 RuntimeException인 경우는 예외처리를 하지 않아도 문법적으로 문제가 되지 않음
 - RuntimeExcption이 아닌 경우는 꼭 예외처리를 해줘야한다. 안하면 에러 발생

 - 두 실수와 산술 연산자가 주어지면 산술연산 결과를 출력하는 코드를 메서드를 생성하여 작성하세요. 예외처리까지 하세요.

 - 클래스 상속
   - 부모 클래스에 있는 멤버 변수/메서드를 자식 클래스가 물려 받는 것
   - 코드의 재사용
   - 자식 클래스들의 객체들을 부모클래스의 객체로 관리 할 수 있다
   - 라이브러리에서 제공하는 클래스를 상속받아 사용할 수 있다.

class Parent{
	int x;
	int y;
}
class Child1 extends Parent{
	int z;
}
class Child2 extends Parent{
	int z, w;
}

public static main(){
	Parent arr[] = new Parent[10];
	arr[0] = new Child1();
	arr[1] = new Child2();
}

 - 상속받은 자식 클래스에서 부모 클래스의 모든 멤버 변수와 메서드를 사용할 수 있다(x)
   => 접근제한자가 public, protected인 경우 사용할 수 있다.
 - 클래스에서 일반적으로 멤버 변수는 private으로, 멤버 메서드는 public으로 접근제한자를 둔다.
 - 메서드 오버라이딩 : 부모 클래스에 있는 메서드를 재정의하는 것

 - 인터페이스 : 추상 메서드와 상수만 있는 것
 - 추상 메서드 : 메서드 구현부가 없이 선언부만 있는 메서드

접근제한자 리턴타입 메서드명(매개변수){
	구현;
}
접근제한자 리턴타입 메서드명(매개변수);
 - 인터페이스는 기능들을 일목요연하게 볼수 있게 해줌
 - 협업할 때 인터페이스를 작성해놓고 기능을 구현하면 개발자들 사이에서 메서드에 대한 형태를 일치시킬 수 있다. => 표준화

 - 컬렉션프레임워크 : 자료를 효율적으로 관리하기 위해 정형화 해 놓은 것
 - 컬렉션 - List, Set : value를 관리
 - Map : key, value를 관리
 - List는 인터페이스, ArrayList는 List 인터페이스를 구현한 클래스
   - 순서 보장, 중복 허용
 - Set는 인터페이스, HashSet는 Set을 구현한 클래스
   - 순서 보장 X, 중복 허용 X
 - Map은 인터페이스, HashMap은 Map을 구현 클래스
   - key, value로 이루어짐
   - key는 중복 불가능, value는 중복 가능
   - 순서 보장 x

 - 컬렉션프레임워크는 배열을 대신한다 생각
 - 데이터가 특징이 없다 => List
 - 데이터가 중복되지 않는다 => Set
 - 데이터의 순서가 중요하다 => List
 - 데이터가 아이디, 패스워드처럼 세트로 관리해야 한다 => Map

 - 앞에서 만든 Point 클래스를 이용하여 점 하나가 (0,0)->(0,1)->(1,1)->(2,1) 로 이동한 경로를 저장하는 코드를 컬렉션 프레임워크를 이용하여 작성하세요.













































 














































